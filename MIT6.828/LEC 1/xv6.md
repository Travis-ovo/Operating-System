# Reference
[xv6中文文档](https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter0.html)  
[xv6 book](https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf)

# Chapter 0 操作系统接口

## 操作系统有什么用?
1. 将计算机的资源在多个程序间共享, 并给程序提供一系列比硬件本身更有用的服务
2. 管理并抽象底层硬件, 例如一个文字处理软件不用去关心自己用的是何种硬盘
3. 多路复用硬件, 使得多个程序可以同时运行
4. 给程序间提供一种受控的交互方式, 使得程序之间可以共享数据, 共同工作

   ![f0-1](https://github.com/Travis-ovo/Operating-System/assets/102942951/20b54958-6a4d-41b2-ada9-d0fb6800540b)  
如图0-1所示，xv6 使用了传统的内核概念: 一个向其他运行中程序提供服务的特殊程序。每一个运行中程序（称之为进程）都拥有包含**指令、数据、栈的内存空间**。\
指令实现了程序的运算，数据是用于运算过程的变量，栈管理了程序的过程调用。\
进程通过**系统调用**使用内核服务. 系统调用会进入内核, 让内核执行服务然后返回. 所以进程总是在用户空间和内核空间之间交替运行\
内核提供的一系列系统调用就是用户程序可见的操作系统接口\
在xv6中, 内核提供了fork()用于创建进程, exit()用于结束当前进程, 等等, 为Unix传统系统调用的一部分

## shell
shell是一个普通的程序, 它接收用户输入的命令然后执行\
shell不是一个特别的用户程序, 很容易被替代\
xv6 shell本质上是一个Unix Bourne shell的简单实现\

## 进程和内存

- 一个xv6进程由两部分组成, 一部分是用户内存空间(指令, 数据, 栈), 另一部分是仅对内核可见的进程状态
- xv6提供了分时特性: 它在可用CPU之间不断切换, 决定哪一个等待中的进程被执行; 当一个进程不在执行时, xv6保存它的CPU寄存器, 当他们再次被执行时恢复这些寄存器的值
- 内核将每个进程和一个pid关联起来process identifier

- 一个进程可以通过系统调用fork来创建, 这样创建的进程被称为子进程
- 子进程的内存内容同创建它发进程一样; fork函数在父进程, 子进程中都返回: 一次调用两次返回
- 对于父进程它返回子进程的pid, 对于子进程返回0
```C
int pid;
pid = fork();
if (pid>0){ //对于父进程返回子进程pid
  printf("parent: child=%d\n", pid);
  pid=wait();
  printf("child %d is done\n", pid);
}else if(pid==0){ // 对于子进程返回0
  printf("child: exiting\n");
  exit();
}else{
  printf("fork error\n");
}
```
- 系统调用exit会导致调用它的进程停止运行, 并且释放诸如内存和打开文件在内的资源
- 系统调用 wait 会返回一个当前进程已退出的子进程，如果没有子进程退出，wait 会等候直到有一个子进程退出。
- 父子进程拥有不同的内存空间和寄存器, 改变一个进程中的变量不会影响另一个进程




























